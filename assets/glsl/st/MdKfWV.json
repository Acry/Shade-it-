[{"ver":"0.1","info":{"id":"MdKfWV","date":"1530646893","viewed":89,"name":"Impossible doughnut","username":"tdhooper","description":"Extracting the 'impossible channel' trick from [url=https:\/\/www.shadertoy.com\/view\/ldKBRt]Eternal Commute[\/url]","likes":13,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EDGE_THICKNESS = .2;\nconst float WIDTH = 1.;\nconst float RADIUS = 3.;\nconst float CHANNEL_DEPTH_RATIO = 1.;\nconst float BALL_COUNT = 19.;\nconst float BALL_SIZE_RATIO = 1.;\nconst float BALL_SPEED = -5.;\nconst float TWISTS = .5;\nconst float TWIST_SPEED = 1.;\n\n\n\/\/ --------------------------------------------------------\n\/\/ IQ\n\/\/ https:\/\/www.shadertoy.com\/view\/ll2GD3\n\/\/ --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Modelling utilities\n\/\/ hg_sdf https:\/\/www.shadertoy.com\/view\/Xs3GRB\n\/\/ --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; \/\/ distance from the plane it lies on\n    float r = length(p.zy); \/\/ distance from center\n    float a = atan(p.y, p.z); \/\/ angle around center\n    return vec3(x, r, a);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.z) * p.y,\n        cos(p.z) * p.y\n    );\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Model\n\/\/ --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 material;\n    vec2 uv;\n    float underStep;\n    int id;\n};\n\n\/\/ Imagine a plane with a channel cut in each side, if the plane were\n\/\/ thin, the channels would cut through to the other side, forming\n\/\/ a hole:\n\/\/ ___     ___\n\/\/ ___|   |___\n\/\/\n\/\/ If the plane were thick, the channels would have depth, and\n\/\/ if it were thick enough, they'd never intersect:\n\/\/ ___     ___\n\/\/    \\___\/\n\/\/     ___\n\/\/ ___\/   \\___\n\/\/\n\/\/ We want to create a thin plane, but with channels that have depth,\n\/\/ don't intersect, and don't create a hole. I've achieved this by\n\/\/ only cutting the channel when we get close to where it would be.\n\n\/\/ The threshold is the surface covering the channel:\n\/\/ ___ ___ ___\n\/\/    \\___\/\n\/\/\n\/\/ This gets set to true when the ray passes through that surface,\n\/\/ into the channel\nbool pastThreshold = false;\n\n\/\/ This is the side of the plane we were on when we crossed\n\/\/ the threshold\nfloat thresholdSide = 0.;\n\nfloat lastZ = 0.; \/\/ Last torus 'z' position or the ray\nbool AO_PASS = false;\nfloat time;\n\nModel fModel(vec3 p) {\n\n    vec3 pp = p;\n    float twist = time * TWIST_SPEED;\n\n    \/\/ Transform space into a torus knot\n    p = cartToPolar(p);\n    p.y -= RADIUS;\n    p.z \/= PI * 2.;\n    pR(p.xy, (TWISTS * p.z + twist) * PI * 2.);\n\n    \/\/ When the ray shoots past the 'join' in the torus,\n    \/\/ flip the side so it matches up\n    if (length(lastZ - p.z) > .5) {\n        thresholdSide *= -1.;\n    }\n    lastZ = p.z;\n\n    float round = EDGE_THICKNESS;\n\n    \/\/ The base plane that we carve into\n    float d = fBox2(\n        p.xy,\n        vec2(WIDTH, EDGE_THICKNESS - round)\n    ) - round;\n\n    float channelWidth = WIDTH - EDGE_THICKNESS \/ 2.;\n    float channelDepth = channelWidth * CHANNEL_DEPTH_RATIO;\n    float channelOffset = channelWidth - channelDepth;\n\n    \/\/ Surface covering the channel, when the ray passes into this,\n    \/\/ we know we're inside the channel\n    float threshold = fBox2(\n        p.xy,\n        vec2(channelWidth + round, EDGE_THICKNESS + .002)\n    );\n\n    \/\/ When the ray passes into the channel for the first time,\n    \/\/ record which side of the plane we were on.\n    \/\/ Always assume we're past the threshold when calculating ambient\n    \/\/ occlusion, as the channel never actually gets cut when\n    \/\/ we're not inside it.\n    if ((AO_PASS || threshold <= 0.) && ! pastThreshold) {\n        pastThreshold = true;\n        thresholdSide = sign(p.y);\n    }\n\n    float side = mix(sign(p.y), thresholdSide, abs(thresholdSide));\n\n    \/\/ Cut the channel when we're past the threshold. This actually\n    \/\/ constructs entirely new geometry, so we don't cut through to\n    \/\/ the other side.\n    if (pastThreshold) {\n        float cut = length(\n            p.xy - vec2(0, channelOffset) * side\n        ) - channelWidth;\n        d = fBox2(\n            p.xy + vec2(0, thresholdSide * (channelDepth * 2. - EDGE_THICKNESS)),\n            vec2(WIDTH, channelDepth * 2. - round)\n        ) - round;\n        d = smax(-cut, d, round);\n    }\n\n    \/\/ A M\u00f6bius strip has a surface length of 2x it's diamater,\n    \/\/ so increment our position when corssing over to the other\n    \/\/ side of the plane\n    if (side > 0.) {\n        p.z += 1.;\n    }\n    p.z \/= 2.;\n\n    float repeat = BALL_COUNT;\n\n    float ballOffset = (time \/ repeat) * BALL_SPEED;\n    p.z += ballOffset;\n\n    \/\/ Divide the strip up into cells\n    float cell = floor((p.z + .5 \/ repeat) * repeat);\n\n    \/\/ Ball position\n    vec3 bp = vec3(0);\n    bp.y = -channelOffset;\n    bp.z = 2. * (cell \/ repeat - ballOffset);\n\n    vec3 col = spectrum(bp.z \/ 2.);\n\n    \/\/ Transform ball's torus position into cartesian space\n    pR(bp.xy, -(TWISTS * p.z + twist) * PI * 2.);\n    bp.y += RADIUS;\n    bp.z *= PI * 2.;\n    bp = polarToCart(bp);\n\n    \/\/ Add the ball sdf, and colour it\n    p = pp;\n    float ballSize = channelWidth * BALL_SIZE_RATIO;\n    float balls = length(p - bp) - ballSize;\n    col = mix(col, vec3(1.), step(d - balls, 0.));\n    d = min(d, balls);\n\n    Model model = Model(d, col, vec2(0), 0., 10);\n    return model;\n}\n\nfloat focalLength;\n\nModel map(vec3 p) {\n    float scale = focalLength;\n    p *= scale;\n    pR(p.yz, 1.25);\n    Model model = fModel(p);\n    model.dist \/= scale;\n    return model;\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Rendering\n\/\/ --------------------------------------------------------\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    float rayLength;\n    vec3 rayDirection;\n};\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 render(Hit hit, vec3 col) {\n    AO_PASS = true;\n    if ( ! hit.isBackground) {\n        float ao = calcAO(hit.pos, hit.normal);\n        float amb = dot(normalize(vec3(1,1,0)), hit.normal) * .5 + .5;\n        float dif = mix(amb, ao, .1);\n        vec3 diffuse = mix(vec3(.5,.5,.6) * .5, vec3(1), dif);\n        col = hit.model.material * diffuse;\n    }\n    return col;\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Ray Marching\n\/\/ Adapted from: https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\/\/ --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.;\nconst float INTERSECTION_PRECISION = .0001;\nconst int NUM_OF_TRACE_STEPS = 1500;\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - .5);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(\n        model,\n        pos,\n        isBackground,\n        normal,\n        rayOrigin,\n        rayLength,\n        rayDirection\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = iTime;\n    time *= .333;\n    time = mod(time, 1.);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n\n    vec3 camPos = vec3(2.5,0,3.5);\n    vec3 camTar = vec3(-.5,0,0);\n    vec3 camUp = vec3(1,0,0);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 bg = vec3(.7,.8,.9) * 1.1;\n\n    Hit hit = raymarch(camPos, rayDirection);\n    vec3 color = render(hit, bg);\n\n    color = pow(color, vec3(1. \/ 2.2)); \/\/ Gamma\n\n    fragColor = vec4(color,1);\n}\n","name":"Image","description":"","type":"image"}]}]