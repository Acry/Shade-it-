[{"ver":"0.1","info":{"id":"4sKBWV","date":"1530595236","viewed":94,"name":"Hexagons on Torus","username":"iq","description":"I feel this is the kind of thing [url=https:\/\/www.shadertoy.com\/user\/Shane]Shane[\/url] would do. Chances are he already made one like this. If so, oh well...","likes":6,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define AA 1   \/\/ make this 2 is you have a fast computer\n\n\/\/------------------------------------------------------------------\n\nvec3 hexagon_pattern( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n\treturn vec3( pi + ca - cb*ma, dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) ) );\n}\n\n\/\/------------------------------------------------------------------\n\nconst vec2 torus = vec2(0.5,0.2);\n\n\/\/------------------------------------------------------------------\n\nvec2 map( in vec3 p )\n{\n    \/\/ plane\n    float d1 = p.y+0.25;\n\n    \/\/ torus\n    float d2 = length( vec2(length(p.xz)-torus.x,p.y) )-torus.y;\n    \n    \/\/ displace torus\n    vec2 uv = vec2( atan(p.z, -p.x), atan(length(p.xz)-torus.x,p.y) )*vec2(9.0*sqrt(3.0), 6.0)\/3.14159;\n    uv.y += iTime;\n    vec3 h = hexagon_pattern( uv );\n    float f = mod(h.x+2.0*h.y,3.0)\/2.0;\n    d2 += f*0.04;\n\n    \/\/ pick one\n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 10.0;\n   \n    float t = 0.8;\n    float m = -1.0;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*0.2;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x*0.1;\n        res = min( res,32.0*h\/t );\n        t += clamp( h, 0.005, 0.025 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n  \nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        float ks = 0.0;\n        \/\/ material        \n        if( m<1.5 )\n        {\n            vec3 te = texture(iChannel0,pos.xz*0.5).xyz;\n            col = te*0.25;\n            ks = te.x;\n            \n            \/\/ fake occlusion\n            col *= smoothstep(0.0,0.4, abs(length(pos.xz)-torus.x) );\n\n            \n        }\n        else\n        {\n            vec2 uv = vec2( atan(pos.z, -pos.x), atan(length(pos.xz)-torus.x,pos.y) )*\n                      vec2(9.0*sqrt(3.0), 6.0)\/3.14159;\n            \n            uv.y += iTime;\n            vec3 h = hexagon_pattern( uv );\n            float f = mod(h.x+2.0*h.y,3.0)\/2.0;\n            \/\/ cell color\n            col = 1.0-vec3( f );\n            \/\/if( col.x<0.01 ) col = vec3(0.2,0.01,0.0);\n            \n            \n            float hh = abs(sin(10.0*(h.x+h.y*2.0)));\n          \/\/if( f<0.1 ) col = vec3(0.2,0.01,0.0);\n            if( f<0.1 ) col = 0.12+0.12*cos(hh+vec3(0.0,2.0,2.0));\n            \n            \/\/ cell borders\n            col *= 0.5+1.5*h.z;\n            \n            \/\/col = mix( col, vec3(0.0,0.1,0.2), 1.0-smoothstep(0.05,0.1,h.z) );\n            \n            \/\/ inner line\n            \/\/col *= 1.0+0.5*sin(31.0*h.z);\n            \n            vec3 te = texture( iChannel0, 0.1*uv ).xyz;\n            col *= te;\n            ks = te.x;\n        }\n\n        \/\/ lighting\n        float occ = calcAO( pos, nor )*(0.5+0.5*nor.y);\n        \n        \n\t\tvec3  lig = normalize( vec3(0.4, 0.5, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        \n        \/\/if( dif>0.0001 )\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.00*dif*vec3(1.10,0.90,0.60);\n        lin += 0.40*amb*vec3(0.30,0.60,2.00)*occ;\n        lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n\t\tcol = col*lin;\n\t\tcol += 6.00*spe*vec3(1.15,0.90,0.70)*ks*ks*4.0;\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\n    \n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n\t\t#endif\n\n\t\t\/\/ camera\t\n        vec3 ro = vec3( 1.1*cos(0.05*iTime + 6.0*mo.x), 0.9, 1.1*sin(0.05*iTime + 6.0*mo.x) );\n        vec3 ta = vec3( 0.0, -0.2, 0.0 );\n        \/\/ camera-to-world transformation\n        vec3 cw = normalize(ta-ro);\n\t\tvec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n\t\tvec3 cv = normalize( cross(cu,cw) );\n        \/\/ ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        \/\/ render\t\n        vec3 col = render( ro, rd );\n\n\t\t\/\/ gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot \/= float(AA*AA);\n\t#endif\n\n    \/\/ gradint\n    tot = 1.25*pow(tot,vec3(0.65,0.9,1.0) );\n\n    \/\/ vignetting    \n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}]