[{"ver":"0.1","info":{"id":"MsVfz1","date":"1527860847","viewed":953,"name":"Neon Lit Hexagons","username":"Shane","description":"A simple raymarched hexagon scene with some neon elements.","likes":64,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tNeon Lit Hexagons\n\t-----------------\n\n\tI needed a break from a few technical shaders I've beem hacking away at, so I finished an old \n\tgeometric example that'd been sitting on the blocks for a while.\n\t\n\t3D hexagon tech imagery is a bit of a cliche, but I've always been a fan. Most tend to be high \n\tquality pathtraced renderings, but since this is a realtime raymarched example, I had to make \n\ta lot of concessions. The glowing neon lights were inspired by some of Shau's examples, some\n\tonline imagery, and practically half the demos out there. :)\n\n\tI tried to create the glowing effect without the use of a volumetric pass, but my eyes weren't\n\taccepting the results, which meant the observant people on here -- pretty much everyone -- would \n\tnotice immediately, so I put a relatively cheap one in. The improvements were immediate, but it\n\twas at the cost of rendering speed... I'm just hoping no one notices the lack of reflections from \n\tthe neon lights. :) I have a pretty quick laptop, but ever since the WebGL 2 update, it hasn't \n\tenjoyed compiling extra passes, so reflections had to go. At a later stage, I might attempt to \n\tfake them in some way.\n\n\tThere are a couple of surface detail defines below that I had to leave out. I also came pretty \n\tclose to greebling the surfaces, but figured that might be overkill. In the end, I took the \n\t\"less is more\" approach. However, I intend to put together a greebled surface pretty soon.\n\n\n    \/\/ Other neon-looking examples:\n\n\t\/\/ Shau has a heap of bright glowing examples, but here's a few.\n\tOTT - shau\n\thttps:\/\/www.shadertoy.com\/view\/4sVyDd\n\n\t43% Burnt - shau\n\thttps:\/\/www.shadertoy.com\/view\/XljBWW\n\n\tAngle Grinder - shau\n\thttps:\/\/www.shadertoy.com\/view\/XtsfWX\n\n\n    \/\/ Great example.\n\tNeon World - zguerrero\n    https:\/\/www.shadertoy.com\/view\/MlscDj\n\n*\/\n\n\n\n\/\/ Hexagon: 0, Dodecahedron: 1, Circle: 2.\n\/\/ Squares, stars, etc, are possible too, but I didn't include those.\n#define SHAPE 0\n\n\n\/\/ Details usually make a scene more interesting. In this case, however, they seemed a\n\/\/ little expensive, so I left them out.\n\/\/\n\/\/ I wanted to include the grooves, at least, but I figured speed on slower machines was\n\/\/ more important.\n\/\/#define ADD_DETAIL_GROOVE \n\/\/#define ADD_DETAIL_BOLT\n\n\/\/ Animating the neon lights, or not. I find them a little too distracting, \n\/\/ so the default is \"off.\"\n\/\/#define ANIMATE_LIGHTS\n\n\/\/ If Borg green is more your thing. :)\n\/\/#define GREEN_GLOW\n\n\/\/ Maximum ray distance.\n#define FAR 50.\n\n\/\/ Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\/\/ vec2 to float hash.\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(7.163, 157.247)); \n    return fract(sin(n)*43758.5453);\n}\n\n\/\/ vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\/*\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n*\/\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n    return n;\/\/abs(n - .5)*2.;\n}\n\n\/\/ Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    \/\/ Four layers of 3D noise.\n    \/\/p \/= 1.5;\n    \/\/p -= vec3(0, 0, iTime*1.);\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    \/\/return vec2(0);\n    \n    \/\/return vec2(sin(z * 0.15)*2.4, cos(z * 0.075)*.15); \n    \n    return vec2(sin(z * 0.15)*2.4, 0);\n}\n\n\n\n\n\/\/\/\/\/\/\n\/\/float objID, svObjID;\n\n\/\/ Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n\/\/ 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(.866025, 1);\/\/const vec2 s = vec2(1, 1.7320508); \/\/\n\n\n\/\/ The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n\/\/ slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    \/\/return length(p);\n    p = abs(p);\n    \n    \/\/ Below is equivalent to:\n    return max(p.x*.866025 + p.y*.5, p.y); \n\n    \/\/return max(dot(p, s*.5), p.x); \/\/ Hexagon.\n    \n}\n\n\/*\n\/\/ More accurate formula, but involves more operations and didn't improve quality by any\n\/\/ significant amount, so I've used the estimation below.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    \n    \/\/ Note the \"*1.5\" You need to take the minimum of\n    \/\/ long-sided rectangles, not squares. Squares will give\n    \/\/ you a dodecahedron.\n    vec3 b = vec3(r*1.5, ht, r); \n    \n    \/\/p.xz = abs(p.xz);\n    \/\/p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    \n    b -= .015;\n    \/\/p.xz = r2(-3.14159\/3.)*q.xz;\n  \tfloat d1 = length(max(abs(p) - b, 0.));\n    p.xz = r2(6.2831\/3.)*p.xz;\n    float d2 = length(max(abs(p) - b, 0.));\n\n    p.xz = r2(6.2831\/3.)*p.xz;\n    float d3 = length(max(abs(p) - b, 0.));    \n    return max(max(d1, d2), d3) - .015;\n}\n*\/\n\n\/\/ Normally, I'd say this is the hexagonal pylon distance function. However, I should \n\/\/ probably make the destinction between a fully bonafide distance function and something\n\/\/ that estimates it. This is a bound of sorts. There's not a great deal between it and \n\/\/ the real thing, but it does exhibit different behaviour away from the surface, which \n\/\/ can affect things like shadows, etc. However, as you can see, in this situation, you\n\/\/ can't really tell. I figured I'd mention this, because myself and others use a lot of\n\/\/ these kind of functions.\n\/\/\n\/\/ Hexagonal pylon field. There's also defines for a dodecahedron and a cylinder.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    vec3 b = vec3(r, ht, r);\n    \n    \n    #if SHAPE == 0\n    \/\/ Hexagon.\n    p.xz = abs(p.xz);\n    p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    \/\/ The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    \/\/ and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #elif SHAPE == 1\n    \/\/ Dodecahedron.\n    p.xz = abs(p.xz);\n    p2 = p.xz*.8660254 + p.zx*.5;\n    p.xz = vec2(max(p2.x, p2.y), max(p.z, p.x));\n    \/\/ The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    \/\/ and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #else\n    \/\/ Cylinder -- IQ's cylinder function, to be precise, so I think this particular\n    \/\/ function is a proper distance field.\n    p.xy = abs(vec2(length(p.xz), p.y)) - b.xy + .015;\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.)) - .015;\n    #endif\n    \n    \n}\n \n\n\n\/\/ IDs for the neon lights. Added at the last minute. Identifying things can be tiresome. Individual \n\/\/ objects need to be identified, and sometimes, objects within objects need identification too.\n\/\/ In this case, there are four pylon groupings. Each pylon object contains a neon light object that \n\/\/ is either on or off.\n\/\/ \n\/\/ If you're seting IDs withing the distance function, they can be lost when calling things like the \n\/\/ \"normal\" function, etc. Therefore, you need extra variables to save the IDs directly after calling \n\/\/ the trace function. Then there's the matter of ID sorting, which should be done outside the loop... \n\/\/ Even with a \"struct,\" or something to that effect, it can still be messy. Having said that, I might \n\/\/ start trying to streamline and formalize the process.\nvec4 litID;\nfloat svLitID;\n\n\/\/ The pylon and light distance field.\n\/\/ Variables in order: p.xz, p.y, radius, height, ID, direction (unused).\nfloat objDist(vec2 p, float pH, float r, float ht, inout float id, float dir){\n    \n    \/\/ Neon light height: Four levels, plus the height is divided by two.\n    const float s = 1.\/16.; \/\/1.\/4.\/2.*.5; \n\n    \/\/ Main hexagon pylon.\n    float h1 = hexPylon(p, pH, r, ht);\n    \n    #ifdef ADD_DETAIL_GROOVE\n    \/\/ I like this extra detail, but it was a little too expensive.\n\th1 = max(h1, -hexPylon(p, pH + ht, r - .06, s\/4.)); \/\/ Extra detail.\n    #endif\n    \n    #ifdef ADD_DETAIL_BOLT\n    \/\/ An alternative extra detail. Also a little on the expensive side.\n    h1 = min(h1, hexPylon(p, pH, .1, ht + s\/4.)); \/\/ Extra detail.\n    #endif\n\n    \n    \n    \/\/ Thin hexagon slab -- sitting just below the top of the main hexagon. It's\n    \/\/ lit differently to represent the neon portion.\n    float h2 = hexPylon(p, pH + ht - s, r + .01, s\/3.);\n    \n     \n    \/\/ Opens a space around the neon lit hexagon. Used, if the radius of \"h2\" is\n    \/\/ less that \"h1,\" which isn't the case here.\n    \/\/h1 = smax(h1, -(abs(pH + ht - s) - s\/3.), .015);\n    \n    \/\/ Identifying the main hexagon pylon or the neon lit portion.\n    id = h1<h2? 0. : 1.;\n    \n    \/\/ Return the closest object.\n    return min(h1, h2);\n    \n}\n\n\/\/ Height field for the hexagon.\nfloat hexHeight(vec2 p){\n    \n    \/\/ Random height.\n    \/\/return hash21(p + 57.)*.75;\n    \n    \/\/ Any kind of cheap flowing height field will do. \n    return dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    \n    \n    \/\/ Two layers. Not used, because we're trying to keep costs down.\n    \/\/float n1 = dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    \/\/float n2 = dot(sin(p.yx*8. - cos(p*6.)), vec2(.25)) + .5;\n    \/\/return n1*.85 + n2*.15;\n}\n\n\n\n\n\/\/ This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n\/\/ hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n\/\/ produce a hexagonal grid.\n\/\/\n\/\/ When working with 2D, I guess it's not that important to streamline this particular function.\n\/\/ However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n\/\/ This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n\/\/ To use it to raymarch, you'd have to double up on everything - in order to deal with \n\/\/ overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p, float pH){\n   \n    \/\/ The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    \/\/ the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    \/\/ center we'll eventually use will depend upon which is closest to the current point. Since \n    \/\/ the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(0, .5))\/s.xyxy) + vec4(0, 0, 0, .5);\n    vec4 hC2 = floor(vec4(p - vec2(.5, .25), p - vec2(.5, .75))\/s.xyxy) + vec4(.5, .25, .5, .75);\n    \n    \/\/ Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - (hC.xy + .5)*s, p - (hC.zw + .5)*s);\n    vec4 h2 = vec4(p - (hC2.xy + .5)*s, p - (hC2.zw + .5)*s);\n    \n    \/\/ Hexagon height.\n    vec4 ht = vec4(hexHeight(hC.xy), hexHeight(hC.zw), hexHeight(hC2.xy), hexHeight(hC2.zw));\n    \/\/ Restricting the heights to five levels... The \".02\" was a hack to take out the lights\n    \/\/ on the ground tiles, or something. :)\n    ht = floor(ht*4.99)\/4.\/2. + .02;\n\n    \/\/ The pylon radius. Lower numbers leave gaps, and heigher numbers give overlap. There's not a \n    \/\/ lot of room for movement, so numbers above \".3,\" or so give artefacts.\n    const float r = .25; \/\/ .21 to .3. \n    vec4 obj = vec4(objDist(h.xy, pH, r, ht.x, litID.x, 1.), objDist(h.zw, pH, r, ht.y, litID.y, -1.), \n                    objDist(h2.xy, pH, r, ht.z, litID.z, -1.), objDist(h2.zw, pH, r, ht.w, litID.w, 1.));\n    \n    \n    \/\/tempD = min(min(obj.x, obj.y), min(obj.z, obj.w));\n    \n    \/\/ Nearest hexagon center (with respect to p) to the current point. In other words, when\n    \/\/ \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    \/\/ in the form of the hexagonal central point.\n    \/\/\n    h = obj.x<obj.y ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    h2 = obj.z<obj.w ? vec4(h2.xy, hC2.xy) : vec4(h2.zw, hC2.zw);\n    \n    vec2 oH = obj.x<obj.y ? vec2(obj.x, litID.x) : vec2(obj.y, litID.y);\n    vec2 oH2 = obj.z<obj.w ? vec2(obj.z, litID.z) : vec2(obj.w, litID.w);\n    \n    \/\/return oH<oH2 ? vec4(h.xy, hC.xy) : vec4(h2.xy, hC2.xy);\n    return oH.x<oH2.x ? vec4(oH,  h.zw) : vec4(oH2, h2.zw);\n    \n}\n\n\/\/ Some IDs. One to save the unique hexagonal center coordinates and an ID for the part of the\n\/\/ pylon that is lit. These were added on the fly. There'd be cleaner ways to do this.\nvec2 v2Rnd, svV2Rnd;\nfloat gLitID;\n\n\n\n\/\/ Reducing the heightmap function to a single texel lookup - via the stone texture which was \n\/\/ generated outside the distance function in the onscreen buffer, of course.\n\/\/\n\/\/ Using the single pass system, there would have been no other option than to generate the stone \n\/\/ texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n\/\/ Voronoi heightmap. :)\nfloat heightMap(in vec3 p){\n\n    \/\/ The stone texture is tileable, or repeatable, which means the pattern is slightly\n    \/\/ repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    \/\/ doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    \/\/return Voronoi(p.xy*2.);\/\/texture2D(texChannel0, fract(p\/2.), -100.).w;\n    \n    const float sc = 1.;\n    vec4 h = getHex(p.xz*sc, -p.y*sc);\n    \n    v2Rnd = h.zw;\n    \n    gLitID = h.y;\n        \n    return h.x\/sc;\n\n}\n\n\/\/\/\/\/\/\/\n\n\/\/ Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float c = heightMap(p);\n    \n    \/\/objID = 1.;\n    \n    return c*.7;\n \n}\n\n\/\/ Global glow variable.\nvec3 glow;\n\n\/\/ Determines whether the neon light should be switched on, or not.\nfloat getRndID(vec2 p){\n    \n    #ifdef ANIMATE_LIGHTS\n    \/\/ Blinking version. Interesting, but I found it too distracting.\n    float rnd = hash21(p);\n    return smoothstep(.5, .875, sin(rnd*6.283 + iTime)); \n    #else\n    return hash21(p) - .75;\n    #endif\n    \n    \n}\n\n\/\/ Standard raymarching routine, with some custom glow mixed in.\nfloat trace(vec3 ro, vec3 rd){\n   \n    \/\/ Applying some jitter to the jump off point to alleviate volumetric banding.\n    float t = hash31(ro + rd)*.25, d, ad;\n\n    glow = vec3(0);\n    \n    \/\/ It's a kind of expensive function, so I'm trying to minimize the iteration number.\n    \/\/ In fact, since the GPU unrolls everything, this number should always be minimized.\n    for (int i = 0; i<80; i++){\n\n        d = map(ro + rd*t);\n        ad = abs(d);\n\n     \tif(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        \/\/ Applying some glow. There are probably better ways to go about it, but this\n        \/\/ will suffice. If the ray passes within \"gd\" units of the neon object, add some\n        \/\/ distance-based glow.\n        const float gd = .1;\n        float rnd = getRndID(v2Rnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { \/\/ && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)\/gd\/(1. + ad*ad\/gd\/gd*8.);\n            \/\/ Colors are possible, but I just wanted the scaler value, which is colorized\n            \/\/ outside the loop.\n            glow += gl; \n        }\n        \n        t += d;  \/\/ Advance the ray.\n    }\n    \n   \n    return min(t, FAR);\n}\n\n\n\n\n\/*\nvoid getGlow(vec3 ro, vec3 rd, float t){\n    \n   glow = vec3(0);\n   float t2 = hash31(ro + rd)*.25, d, ad;\n   t2 = max(t2 - 3., 0.);\n\n   for (int i = 0; i<30; i++){\n       \n\t\td = map(ro + rd*t2);\n        ad = abs(d);\n\n        if(ad<.001*(t2*.125 + 1.) || t2>FAR) break;\n\n        const float gd = .1;\n        float rnd = getRndID(vRnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { \/\/ && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)\/gd\/(1. + ad*ad\/gd\/gd*8.);\n            glow += gl;\n        }\n       \n\t\tt2 += d;\n        \n    }\n    \n   \n    \n}\n*\/\n\n\/*\n\/\/ Second pass, which is the first, and only, reflected bounce. \n\/\/ Virtually the same as above, but with fewer iterations and less \n\/\/ accuracy.\n\/\/\n\/\/ The reason for a second, virtually identical equation is that \n\/\/ raymarching is usually a pretty expensive exercise, so since the \n\/\/ reflected ray doesn't require as much detail, you can relax things \n\/\/ a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i<32; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.25 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n*\/\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/dist += min(h, stepDist); \/\/ So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        dist += clamp(h, .02, .25); \/\/ So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n\/\/ the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate\n    \/\/ artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*\/\n\n\/*\n\/\/ Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { \n\t\n    \/\/ Roughly two pixel edge spread, but increased slightly with larger resolution.\n    vec2 e = vec2(ef\/mix(450., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n\n      \n    \/\/ Wider sample spread for the curvature.\n    \/\/e = vec2(12.\/450., 0);\n\t\/\/d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t\/\/d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t\/\/d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    \/\/crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \t \n    \n    e = vec2(.0025, 0); \/\/iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*\/\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125\/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    \/\/p.xz += iTime*.5;\n    \n    float n3D2 = noise3D(p*3.);\n   \n    \/\/ A bit of fBm.\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); \/\/ Bluish tinge.\n    \n    return mix(p, p.zyx, n3D2*.25 + .75); \/\/ Mixing in a bit of purple.\n\n}\n\n\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    \n    \/\/p.xy -= path(p.z);\n    float sz0 = 1.\/2.;\n    \n    \/\/ Texel retrieval.\n    vec3 txP = p;\n    \/\/txP.xz *= r2(getRndID(svVRnd)*6.2831);\n    vec3 col = tex3D(iChannel0, txP*sz0, n );\n    col = smoothstep(-.0, .5, col);\/\/*vec3(.5, .8, 1.5);\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    \/\/ Darken the surfaces to bring more attention to the neon lights.\n    col \/= 16.;\n    \n   \n    \/\/ Unique random ID for the hexagon pylon.\n    float rnd = getRndID(svV2Rnd);\n    \n    \/\/ Subtly coloring the unlit hexagons... I wasn't feeling it. :)\n    \/\/if(svLitID==1. && rnd<=.0) col *= vec3(1, .85, .75)*4.;\n\n    \/\/ Applying the glow.\n    \/\/\n    \/\/ It's took a while to hit upon the right combination. You can create a cheap lit object \n    \/\/ effect by simply ramping up the object's color intensity. However, your eyes can tell that\n    \/\/ it's lacking that volumetric haze. Volumetric haze is achievable via a volumetric appoach.\n    \/\/ However, it's prone to patchiness. The solutionm, of course, is to combine the smoothness\n    \/\/ of direct object coloring with a portion of the glow. That's what is happining here.\n\n    \/\/ Object glow.\n    float oGlow = 0.;\n    \n    \/\/ Color every lit object with a gradient based on its vertical positioning.\n    if(rnd>0. && svLitID==1.) {\n        \n        float ht = hexHeight(svV2Rnd);\n    \tht = floor(ht*4.99)\/4.\/2. + .02;\n        const float s = 1.\/4.\/2.*.5; \/\/ Four levels, plus the height is divided by two.\n     \n        oGlow = mix(1., 0., clamp((abs(p.y - (ht - s)))\/s*3.*1., 0., 1.));\n        oGlow = smoothstep(0., 1., oGlow*1.);\n    }\n    \n    \/\/ Mix the object glow in with a small potion of the volumetric glow.\n    glow = mix(glow, vec3(oGlow), .75);\n    \n    \/\/ Colorizing the glow, depending on your requirements. I've used a colorful orangey palette,\n    \/\/ then have modified the single color according to a made up 3D transcental function.\n    \/\/glow = pow(vec3(1, 1.05, 1.1)*glow.x, vec3(6, 3, 1));\n    glow = pow(vec3(1.5, 1, 1)*glow, vec3(1, 3, 6)); \/\/ Mild firey orange.\n    glow = mix(glow, glow.xzy, dot(sin(p*4. - cos(p.yzx*4.)), vec3(.166)) + .5); \/\/ Mixing in some pink.\n    glow = mix(glow, glow.zyx, dot(cos(p*2. - sin(p.yzx*2.)), vec3(.166)) + .5); \/\/ Blue tones.\n    \/\/glow = mix(glow.zyx, glow, smoothstep(-.1, .1, dot(sin(p + cos(p.yzx)), vec3(.166))));\n     \n    #ifdef GREEN_GLOW \n    glow = glow.yxz;\n    #endif\n    \n   \n    return col;\n    \n}\n\n\n\/\/ Using the hit point, unit direction ray, etc, to color the \n\/\/ scene. Diffuse, specular, falloff, etc. It's all pretty \n\/\/ standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, in float t){\n    \n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n           \/\/ Texture bump the normal.\n    \tfloat sz0 = 1.\/1.;\n    \tvec3 txP = sp;\n        \/\/txP.xy -= path(txP.z);\n        \/\/txP.xz *= r2(getRndID(svVRnd)*6.2831);\n        sn = texBump(iChannel0, txP*sz0, sn, .005);\/\/\/(1. + t\/FAR)\n \n\n        \/\/ Retrieving the normal at the hit point.\n        \/\/sn = getNormal(sp);  \n        float sh = softShadow(sp, lp, 12.);\n        float ao = calcAO(sp, sn);\n        sh = min(sh + ao*.3, 1.);\n\n        vec3 ld = lp - sp; \/\/ Light direction vector.\n        float lDist = max(length(ld), .001); \/\/ Light to surface distance.\n        ld \/= lDist; \/\/ Normalizing the light vector.\n\n        \/\/ Attenuating the light, based on distance.\n        float atten = 1.5\/(1. + lDist*.1 + lDist*lDist*.02);\n\n        \/\/ Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        \/\/if(svLitID == 0.) diff = pow(diff, 4.)*2.;\n        \/\/ Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n        float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); \/\/ Fresnel reflection term.\n        \/\/float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        \/\/float fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5.\n        \n\n\n        \/\/ Coloring the object. You could set it to a single color, to\n        \/\/ make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n\n        \/\/ Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + vec3(1, .6, .3)*spec*4. + .5*ao + vec3(.3, .5, 1)*fres*fres*2.);\n\n        \/\/ Fake environment mapping.\n        sceneCol += pow(sceneCol, vec3(1.))*envMap(reflect(rd, sn))*4.;\n        \n       \n        \/\/ Applying the shadows and ambient occlusion.\n        sceneCol *= atten*sh*ao;\n        \n        \/\/ For whatever reason, I didn't want the shadows and such to effect the glow, so I layered\n        \/\/ it over the top.\n        sceneCol += (objCol*6. + 1.)*glow; \/\/*(sh*.35 + .65);\n \n        \/\/sceneCol = vec3(sh);\n    \n    }\n    \n    \n\n    \n    \/\/ Return the color. Done once every pass... of which there are\n    \/\/ only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) \/ iResolution.y;\n    \n\t\n\t\/\/ Camera Setup.\n\t\/\/vec3 lookAt = vec3(0., 0.25, iTime*2.);  \/\/ \"Look At\" position.\n\t\/\/vec3 camPos = lookAt + vec3(2., 1.5, -1.5); \/\/ Camera position, doubling as the ray origin.\n\t\n\tvec3 lk = vec3(0, 1.25, iTime*2.);  \/\/ \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .175, -.25); \/\/ Camera position, doubling as the ray origin.\n\n   \n    \/\/ Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, 4); \/\/4\n    \n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \/\/ Camera lean.\n    \/\/rd.xy *= r2(path(lk.z).x\/32.);\n    \/\/\/\/\/\/\/\/\/\n    \n\n    vec3 sceneColor, passColor, sn, sSn;\n\n    \n    \n    \/\/ FIRST PASS.\n    \n    float t = trace(ro, rd);\n    svV2Rnd = v2Rnd;\n    svLitID = gLitID;\n\n    \n    \/\/getGlow(ro, rd, t);\n    \n    \/\/ Fog based off of distance from the camera. Not used here.\n    float fog = smoothstep(0., FAR-1., t); \n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n   \n    \/\/ Retrieving the normal at the hit point.\n    \/\/sn = getNormal(ro); \n    \/\/float edge = 0., crv = 1., ef = 5.;\n\t\/\/sn = getNormal(ro, edge, crv, ef);\/\/\n    \/\/sSn = sn; \/\/ Save the unpeturbed normal.\n    sn = getNormal(ro);\n    \n    \n    \n    \/\/ Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    \/\/ the ray origin to describe the surface hit point is kind of confusing. The reason \n    \/\/ we do it is because the reflective ray will begin from the hit point in the \n    \/\/ direction of the reflected ray. Thus the new ray origin will be the hit point. \n    \/\/ See \"traceRef\" below.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = passColor;\/\/*(1. - edge*.8);\/\/mix(passColor, vec3(0), fog); \/\/\n    \n    \n    \n    \/\/ Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    \/\/ first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    \/\/float sh = softShadow(ro, lp, 12.);\n    \/\/sh *= calcAO(ro, sn);\n    \n\/*    \n    \/\/ SECOND PASS - REFLECTED RAY\n    \n    \/\/ Standard reflected ray, which is just a reflection of the unit\n    \/\/ direction ray off of the intersected surface. You use the normal\n    \/\/ at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, normalize(sSn*.66 + sn*.34));\n    \n    \n    \n    \n    \/\/ The reflected pass begins where the first ray ended, which is the suface\n    \/\/ hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    \/\/ of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    \/\/ of wasteful, but not really noticeable. The direction of the new ray will\n    \/\/ obviously be in the direction of the reflected ray. See just above.\n    \/\/\n    \/\/ To anyone who's new to this, don't forgot to nudge the ray off of the \n    \/\/ initial surface point. Otherwise, you'll intersect with the surface\n    \/\/ you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    svVRnd = vRnd;\n    svObjID = objID;\n    \n    \/\/ Advancing the reflected ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the new normal at the reflected hit point.\n    \/\/sn = getNormal(ro); \n    float edge2 = 0., crv2 = 1.;\/\/, ef2 = 8.;\n\tsn = getNormal(ro, edge2, crv2, ef);\/\/getNormal(sp);\n\n    \n    \/\/ Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    \/\/ How much you add depends on what you're trying to accomplish.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor*.5 + passColor*(1. - edge2*.8);\/\/mix(passColor, vec3(0), fog);\n    \n*\/  \n    \n    \/\/sceneColor *= (1. - edge*.8);\n    \n    \n    \/\/ APPLYING SHADOWS\n    \/\/\n    \/\/ Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    \/\/ see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    \/\/ save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    \/\/ occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    \/\/sceneColor *= sh;\n    \n    sceneColor = mix(sceneColor, vec3(0), fog);\n    \n\n    \/\/ Square vignette.\n    uv = fragCoord\/iResolution.xy;\n    sceneColor = min(sceneColor, 1.)*pow( 16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n    \/\/ Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}]