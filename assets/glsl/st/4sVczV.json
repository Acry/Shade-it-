[{"ver":"0.1","info":{"id":"4sVczV","date":"1522669971","viewed":2972,"name":"h e e e l i x","username":"tdhooper","description":"My entry for the Revision 2018 Animated GIF Compo (1st place \\o\/), with an extra bit of post process that blew the file size limit.\n\nUncomment ANOTHER_LEVEL to go deeper","likes":102,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/#define ANOTHER_LEVEL\n\n\nfloat guiLead = 0.6;\nfloat guiInnerRatio = 0.4407892623709694;\nfloat guiFocal = 3.;\nfloat guiRotateModel = 0.4560833039600971;\nfloat guiDebug = 0.6749066960348409;\nfloat guiZipOffset = 30.;\nfloat guiZipSize = 60.;\nfloat guiZipSpeed = 3.3;\nfloat guiZoom = 0.1;\nfloat guiModelScale = 7.749066960348409;\n\nmat4 cameraMatrix = mat4(\n    -0.7063226699829102,\n    0.7052236199378967,\n    0.06198469549417496,\n    0,\n    -0.30620118975639343,\n    -0.3832840919494629,\n    0.8714323043823242,\n    0,\n    0.6382971405982971,\n    0.5965006947517395,\n    0.48660656809806824,\n    0,\n    0.14653973281383514,\n    0.6211488246917725,\n    0.13233166933059692,\n    1\n);\n\nvec3 camPosition = vec3(0.14653973281383514, 0.6211488246917725, 0.13233166933059692);\n\nfloat time;\n\n#define PI 3.14159265359\n#define HALF_PI 1.5707963267948966\n#define TAU 6.28318530718\n#define PHI 1.618033988749895\n\n\n\/\/ --------------------------------------------------------\n\/\/ Utils\n\/\/ --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\/\/ Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n\/\/ Read like this: R(p.xz, a) rotates \"x towards z\".\n\/\/ This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\/\/ http:\/\/www.neilmendoza.com\/glsl-rotation-about-an-arbitrary-axis\/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) \/ (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\/\/ Repeat space along one axis. Use like this to repeat along the x axis:\n\/\/ <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)\/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; \/\/ distance from the plane it lies on\n    float a = atan(p.y, p.z); \/\/ angle around center\n    float r = length(p.zy); \/\/ distance from center\n    return vec3(x, a, r);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Helix\n\/\/ https:\/\/www.shadertoy.com\/view\/MstcWs\n\/\/ --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    \/\/ Angle of the line\n    float a = atan(line.x, line.y);\n\n    \/\/ Rotate space so we can easily repeat along\n    \/\/ one dimension\n    pR(point, -a);\n\n    \/\/ Repeat to create parallel lines at the corners\n    \/\/ of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    \/\/ Rotate space back to where it was\n    pR(point, a);\n\n    \/\/ Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    \/\/ Part 2 of the repeat, move the line along it's\n    \/\/ tangent by the repeat cell\n    vec2 tangent = vec2(line.y, -line.x);\n    closest += cell * repeatSize * tangent;\n\n    return closest;\n}\n\n\/\/ Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y \/= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n\/\/ Cartesian to helix coordinates\nvoid pModHelix(inout vec3 p, float lead, float radius) {\n    vec3 closest = closestHelix(p, lead, radius);\n    float helixAngle = atan((2. * PI * radius) \/ lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x \/ lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    p = vec3(x, y, z);\n}\n\nfloat pModHelixScale(inout vec3 p, float lead, float innerRatio) {\n    float radius = mix(.25, .5, innerRatio);\n    pModHelix(p, lead, radius);\n    float scale = mix(.5, 0., innerRatio);\n    p \/= scale;\n    return 1. \/ scale;\n}\n\nfloat pModHelixUnwrap(inout vec3 p, float lead, float innerRatio, float t) {\n    float radius = mix(.25, .5, innerRatio);\n    float width = cos(asin(t));\n    float adjust = (1. \/ width);\n    float offset = ((.5 * adjust) - .5) * 7.;\n\n    vec3 pp = p;\n    pp.z -= radius;\n    pR(pp.xy, PI * -.5);\n    pp.x *= -1.;\n\n    p.z += offset;\n    radius += offset;\n    pModHelix(p, lead, radius);\n\n    p = mix(p, pp, rangec(.8, 1., t));\n\n    float scale = mix(.5, 0., innerRatio);\n    p \/= scale;\n    return 1. \/ scale;\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Modelling\n\/\/ --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    int id;\n};\n\nfloat anim(float t, float index) {\n    float overlap = .5;\n    float steps = 2.;\n    float all = mix(steps, 1., overlap);\n    float width = 1. \/ (all - 1.);\n    float each = width * (1.- overlap);\n    float start = index * each - width * .5;\n    float end = start + width;\n    return range(start, end, t);\n}\n\nfloat unzip(vec3 p, float t) {\n    float size = guiZipSize;\n    float speed = guiZipSpeed;\n\n    t *= size * speed;\n\n    if (sign(p.y) != sign(p.x)) {\n        float radius = mix(.25, .5, guiInnerRatio);\n        float scale = mix(.5, 0., guiInnerRatio);\n        float factor = radius \/ scale * PI * 2.;\n        t -= (factor - .5);\n    }\n\n    return range(size, 0., abs(p.x) + size - t);\n}\n\nvoid addPipe(inout float d, vec3 p, float scale, float tt) {\n\n    float t = clamp(tt, 0., 1.);\n\n    float boundry = 1.;\n    float part;\n    float separate = (\n        rangec(0., boundry * .01, t) * .3 +\n        rangec(boundry * .01, boundry, t) * .7\n    );\n\n    float round = rangec(.0, 1., t);\n\n    part = fBox2(p.yz, vec2(mix(guiLead * 2., .5, separate), .5));\n    part = mix(part, length(p.yz) - .5, round);\n    part \/= scale;\n\n    d = mix(d, part, smoothstep(.0, .01, t));\n}\n\nvoid unzipHelixModel(inout float d, inout float scale, inout vec3 p, float lead, float innerRatio, float step, float invert) {\n    float offset = guiZipOffset \/ lead;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n    float t1 = unzip(p + vec3(offset,0,0) * invert, anim(time, step));\n    addPipe(d, p, scale, t1);\n}\n\nModel map(vec3 p) {\n\n    float part, d, t1, t2, t3, t4;\n    float lead = guiLead;\n    float innerRatio = guiInnerRatio;\n    vec2 uv1, uv2, uv3;\n\n    p \/= guiModelScale;\n\n    vec3 pp = p;\n\n    d = 1e12;\n\n    float s = mix(.5, 0., innerRatio);\n\n    float scale = 1.\/pow(1.\/s, time);\n\n    pR(p.xy, PI * -.5 * time + guiRotateModel * PI * 2.);\n    \n    p *= scale;\n    p.z += .5;\n\n    scale *= pModHelixUnwrap(p, lead, innerRatio, time);\n    p.x *= -1.;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n\n    #ifdef ANOTHER_LEVEL\n        scale *= pModHelixScale(p, lead, innerRatio);\n        p.x *= -1.;\n    #endif\n\n    d = min(d, length(p.yz) - .5);\n    d \/= scale;\n\n    unzipHelixModel(d, scale, p, lead, innerRatio, -1., 1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 0., -1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 1., 1.);\n\n    d *= guiModelScale;\n\n    return Model(d, vec3(0), 1);\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Rendering\n\/\/ --------------------------------------------------------\n\nconst float OUTLINE = .003; \/\/ Outline thickness\nconst float OUTLINE_BOUNDRY = .5; \/\/ Where to feather the inside\/outside\nconst float MAX_TRACE_DISTANCE = 1.5; \/\/ max trace distance\nconst float INTERSECTION_PRECISION = .001; \/\/ precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; \/\/ Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\n\/\/ Faster runtime\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n\/\/ Faster compilation\nconst int NORMAL_STEPS = 6;\nvec3 _calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 10.0*h\/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\/\/ Adapted from https:\/\/www.shadertoy.com\/view\/Xds3zN\nvec3 doLighting(vec3 pos, vec3 nor, vec3 rd) {\n\n    vec3 col;\n    vec3 up = normalize(vec3(1));\n\n    \/\/ lighitng        \n    float occ = mix(calcAO( pos, nor ), 1., .8);\n    vec3  lig = normalize(vec3(0,.2,1));\n    float amb = clamp(dot(nor, up) * .5 + .5, 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    vec3  hal = normalize( lig-rd );\n    float spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n\n    vec3 cA = vec3(.7,.3,.9);\n    vec3 cB = vec3(.4,.9,.8);\n    vec3 cC = vec3(.7,0,.7);\n\n    col = mix(cA, cB, rangec(.0, 1., dot(-rd, nor))); \/\/ need better ramp\n    col = mix(col, vec3(.8,.5,1), rangec(.5, 1., dif) * .5);\n    col += cC * rangec(.5, 1., dif) * .1;\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 ) * .9;\n\n    vec3 lin = vec3(0);\n    lin += .5 * dif;\n    lin += .1 * spe * dif;\n    lin += .2 * fre * occ;\n    lin += .5 * amb * occ;\n    lin += .4 * occ;\n    col = col*lin;\n\n    return col;\n}\n\nvec3 background;\n\nvoid applyFog(inout vec3 color, vec3 pos) {\n    float fog = length(camPosition - pos);\n    fog = smoothstep(float(MAX_TRACE_DISTANCE) * .36, float(MAX_TRACE_DISTANCE), fog);\n    color = mix(color, background, fog);\n}\n\nvec3 shadeSurface(vec3 pos, Ray ray) {\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        return background;\n    }\n\n    vec3 normal = calcNormal(pos);\n\n    vec3 color = doLighting(\n        pos,\n        normal,\n        ray.direction\n    );\n\n    applyFog(color, pos);\n    \n    return color;\n}\n\nvec4 shadeOutline(vec3 pos, float t) {\n    float alpha = smoothstep(0., OUTLINE_BOUNDRY, t);\n    alpha -= smoothstep(OUTLINE_BOUNDRY, 1., t);\n    alpha *= .5;\n\tvec3 color = vec3(0);\n    applyFog(color, pos);\n    return vec4(color, alpha);\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Ray Marching\n\/\/ --------------------------------------------------------\n\nvec3 raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float lastDist = currentDist;\n    vec3 pos, lastPos = vec3(0);    \n    vec4 outline = vec4(0);\n    \n    Model model;\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for (int i = 0; i < NUM_OF_TRACE_STEPS; i++) {\n\n        lastPos = pos;\n        pos = ray.origin + ray.direction * ray.len;\n\n        if (ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        if (currentDist < INTERSECTION_PRECISION) {\n            break;\n        }\n\n        if (currentDist > lastDist && currentDist < OUTLINE) {\n\n            float t = lastDist \/ OUTLINE;\n            \n            vec4 newOutline = shadeOutline(pos, t);\n            float contribution = 1. - outline.a;\n            outline.rgb = mix(outline.rgb, newOutline.rgb, contribution);\n            outline.a += newOutline.a * contribution;\n\n            if (t < OUTLINE_BOUNDRY) {\n                pos = lastPos;\n                break;\n\t\t\t}\n        }\n\n        model = map(pos);\n        lastDist = currentDist;\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\t\n    vec3 color = mix(\n        shadeSurface(pos, ray),\n       \toutline.rgb,\n        outline.a\n\t);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n\n    vec3 bgA = vec3(.6,.5,.8) * .55;\n    vec3 bgB = vec3(.7,.9,1.) * .5;\n    background = mix(bgA, bgB, dot(p, normalize(vec2(.2,-.6))) * .5);\n    \/\/background = mix(vec3(.4,.3,.5) * .9, vec3(.6), -.2);\n\n    time = iTime;\n    time *= .6;\n    time += .53;\n    time = mod(time, 1.);\n    \n    float camDist = length(camPosition);\n\n    mat4 camMat = cameraMatrix;\n    float focalLength = guiFocal;\n    vec3 rd = normalize(\n        (vec4(p, -focalLength, 1) * camMat).xyz\n    );\n    \n    vec3 color = raymarch(CastRay(camPosition, rd));\t\n    \n    vec2 uv = fragCoord\/iResolution.xy;\n    float vig = pow(\n        16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y),\n        0.075\n    );\n    color *= vec3(.9, .95, 1.) * vig * 1.1;\n\n    color = mix(color, vec3(pow(length(color * .6), 2.)), .1);\n    color *= 1.05;\n    color = pow(color, vec3(1.2,1.3,1.2));\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}]