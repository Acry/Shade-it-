[{"ver":"0.1","info":{"id":"ldGfWt","date":"1531058074","viewed":7,"name":"GP_Dashing","username":"mv","description":"Construct dashed lines using a repeating smoothing kernel of different wavelengths and ratios that can be composed to produce different patterns. More in comments.","likes":1,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f(float x, float l, float r) {\n    \/\/ The main idea here is to generate a step function which smoothly blends between the steps\n    \/\/\n    \/\/ We construct a function that periodically goes from 1 to 0 and back to 1 again\n    \/\/ with a certain wavelength l using a linear ramp, like so:\n    \/\/  ___          ____\n    \/\/     \\        \/\n    \/\/      \\______\/\n    \/\/\n    \/\/ which is then passed through a smoothstep function to smoothen the ramp.\n    \/\/\n    \/\/ Parameters:\n    \/\/\n    \/\/     x: running value (distance along line)\n    \/\/     l: wavelength - the distance of a repeated pattern\n    \/\/     r: ratio of 1 to 0 values. r = 1.0 makes a solid line. r = 0.0 makes no lines. \n    \/\/     w: the smoothing width, the distance it takes to reach from 0 to 1, and vice versa. \n    \/\/\n    \/\/ the `w` parameter isn't so useful for horizontal or vertical lines, but is quite useful for \n    \/\/ curved or diagonal lines for anti-aliasing. \n    \/\/ \n    \n    float w = 1.0; \/\/ pixel smoothing length hard coded\n    \n    x = mod(x, l); \/\/ doesn't work for negative numbers, replace it with x - l*floor(x\/l) if needed. \n    \n    \/\/                1 for x = 0..a\n    \/\/ ramp from 1 to 0 for x = a..b\n    \/\/                0 for x = b..c\n    \/\/ ramp from 0 to 1 for x = c..d\n    \/\/                1 for x = d..1\n    float a = l*r\/2.0 - w\/2.0;\n    float b = l*r\/2.0 + w\/2.0;\n    float c = l - b;\n    float d = l - a;\n\n    \/\/ this can probably be made non-branching with some math, but cba right now. \n    if (x < a) {\n        x = 1.0;\n    } else if (x < b) {\n        x = 1.0 - (x - a)\/w;\n    } else if (x < c) {\n        x = 0.0;\n    } else if (x < d) {\n        x = (x - c)\/w;\n    } else {\n        x = 1.0;\n    }\n    \n    return 1.0 - smoothstep(0.0, 1.0, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ repeat vertically\n    int N = 13;\n    vec2 p = fragCoord.xy;\n    int y = int(floor(float(N)*p.y\/iResolution.y));\n    p.y = mod(p.y, iResolution.y\/float(N));\n    p.y = p.y - 0.5*iResolution.y\/float(N);\n    \n    \/\/ Compose each section separately\n    float d;\n    if      (y ==  0) d = f(p.x, 20.0, 0.1);\n    else if (y ==  1) d = f(p.x, 20.0, 0.2);\n    else if (y ==  2) d = f(p.x, 20.0, 0.3);\n    else if (y ==  3) d = f(p.x, 20.0, 0.4);\n    else if (y ==  4) d = f(p.x, 20.0, 0.5);\n    else if (y ==  5) d = f(p.x, 20.0, 0.6);\n    else if (y ==  6) d = f(p.x, 20.0, 0.7);\n    else if (y ==  7) d = f(p.x, 20.0, 0.8);\n    else if (y ==  8) d = f(p.x, 20.0, 0.9);\n    else if (y ==  9) d = f(p.x, 20.0, 1.0);\n    else if (y == 10) d = min(f(p.x, 20.0, 0.2), f(p.x, 40.0, 0.3));\n    else if (y == 11) d = min(f(p.x, 20.0, 0.2), f(p.x, 60.0, 0.3));\n    else if (y == 12) d = f(p.x, 6.0, 0.4);\n    else              d = 1.0;\n    \n    \/\/ blend vertically\n    float s = smoothstep(0.5, -0.5, abs(p.y) - 1.0);\n    d = d*s + 1.0*(1.0 - s);\n        \n    fragColor = vec4(vec3(d),1.0);\n}","name":"Image","description":"","type":"image"}]}]