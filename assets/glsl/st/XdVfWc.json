[{"ver":"0.1","info":{"id":"XdVfWc","date":"1530915135","viewed":84,"name":"SpiralGalaxy","username":"felipunkerito","description":"Mouse rotates the camera.\nJust a 3D spiral inspired by: [url=https:\/\/www.shadertoy.com\/view\/Msc3z8]iapafoto[\/url] and \n                                        [url=https:\/\/www.shadertoy.com\/view\/Xsl3zX]FabriceNeyret2[\/url]","likes":4,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS         64\n#define FAR          10.\n#define PI  acos( -1.0 )\n#define TPI     2.0 * PI\n\/\/ iq's procedural vs from texture noise, uncomment at your own risk\n\/\/#define PROCEDURAL\n#define HASHSCALE  .1031\n#define NB_ARMS     3.0\n\n\n\/\/ From iapafoto's slightly modded\nfloat spiral(in vec3 p) {\n    float a = atan(p.y,p.x)+iTime;\n\tfloat r = length(p.xy);\n    float lr = 2.0 * log(r);\n    float th = 0.05-0.4*r; \/\/ thickness according to distance\n    float d = fract(.5*(a-lr*1.)\/PI); \/\/apply rotation and scaling.\n    float phase = NB_ARMS*(a-lr);\n    \n    d = cos( phase );\n\t\n    d = (.1-abs(d-0.1))*2.*PI*r\/32.;\n\n    return sqrt(d*d+p.z*p.z)-th*r;\n    \n}\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n               \t sin( a ),  cos( a )\n               );\n\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ iq's\n#ifdef PROCEDURAL\n\nfloat noise( in vec3 x )\n{\n    \n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\n#else\n\nfloat noise( in vec3 x )\n{\n\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n    \n}\n\n#endif\n\nfloat fbm( in vec3 p )\n{\n\n    p.xy *= rot( iTime );\n    \n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02; \/\/p -= iTime + WAV;\n    f += 0.2500 * noise( p ); p *= 2.03; \/\/p += iTime + FRE;\n    f += 0.1250 * noise( p ); p *= 2.01; \/\/p -= iTime + WAV;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f \/ 0.9375;\n    \n}\n\nfloat map( vec3 p )\n{\n    \n    float f = 0.0;\n    \n    f = 1.5 - spiral( p ) + fbm( p ) * 0.3;\n    \n    return f;\n    \n}\n\nfloat ray( vec3 ro, vec3 rd, out float den )\n{\n\n    float t = 0.0, maxD = 0.0, d = 1.0; den = 0.0;\n    \n    for( int i = 0; i < STEPS; ++i )\n    {\n        \n        vec3 p = ro + rd * t;\n    \n        den = 0.3 * map( p );\n        \/\/den = map( p );\n        maxD = maxD < den ? den : maxD;\n        \n        if( maxD > 1.0 || t > FAR ) break;\n        \n        \/\/ https:\/\/www.shadertoy.com\/view\/MscXRH\n        t += max( maxD*.1, .05 );\n        \n        \/\/t += 0.05;\n    \n    }\n    \n    den = maxD;\n    \n    return t;\n\n}\n\nvec3 shad( vec3 ro, vec3 rd, vec2 uv )\n{\n\n    float den = 0.0;\n    float t = ray( ro, rd, den );\n    \n    vec3 p = ro + rd * t;\n\n    vec3 col = mix( vec3( 0 ), \n               \t\tmix( vec3( 0.4, 0.1, 0.2 ),\n               \t\tvec3( 0.9, 0.9, 0.5 ), \n               \t\tden ),\n                   den * 4.0 );\n    \n    col *= sqrt( col );\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) \/ iResolution.y;\n\n    vec2 mou = -iMouse.xy \/ iResolution.xy;\n\n    vec3 ro = vec3( 0.0, 0.0, 1.5 );\n    vec3 rd = normalize( vec3( uv, -1.0 ) );\n    \n    if( iMouse.z > 0.5 )\n    {\n    \n    \tro.zy *= rot( mou.y * TPI );\n    \trd.zy *= rot( mou.y * TPI );\n    \tro.xy *= rot( mou.x * TPI );\n    \trd.xy *= rot( mou.x * TPI );\n    \n        \n    }\n    \n    if( iMouse.z < 0.5 )\n    {\n    \n    \tro.zy *= rot( iTime * 0.1 );\n    \trd.zy *= rot( iTime * 0.1 );\n    \tro.xy *= rot( iTime * 0.1 );\n    \trd.xy *= rot( iTime * 0.1 );\n    \n        \n    }\n        \n    float den = 0.0, t = ray( ro, rd, den );\n    \n    vec3 col = shad( ro, rd, uv );\n    \n    \/\/ Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}]